#!/usr/bin/env node
const { version } = require('../package.json');
const path = require('path');
const fs = require('fs');
const Async = require('async');

const { Command } = require('commander');

const migrate = require('../lib/migrate');
const pathConfig = require('../lib/pathconfig');

(async () => {
  const program = new Command();

  program
    .version(
      version,
      '-v, --vers',
      'Current version of sequelize-migrations-generator',
    )
    .description('Apply migrations generated by "makemigrations"')
    .option(
      '-r, --require <value...>',
      'Pass a dependency that should be executed before',
    )
    .option('--rev <number>', 'Set migration revision (default: 0)', 0)
    .option('-p, --pos <number>', 'Run first migration at pos (default: 0)', 0)
    .option('--one', 'Do not run next migrations', false)
    .option('-l, --list', 'Show migration file list (without execution)', false)
    .option('--migrations-path <value>', 'The path to the migrations folder')
    .option('--models-path <value>', 'The path to the models folder');

  program.parse(process.argv);

  // Windows support
  if (!process.env.PWD) {
    process.env.PWD = process.cwd();
  }

  let { migrationsDir, modelsDir } = pathConfig(program);

  if (!fs.existsSync(modelsDir)) {
    console.log(
      "Can't find models directory. Use `sequelize init` to create it",
    );
    return;
  }

  if (!fs.existsSync(migrationsDir)) {
    console.log(
      "Can't find migrations directory. Use `sequelize init` to create it",
    );
    return;
  }

  const sequelize = require(modelsDir).sequelize;
  const queryInterface = sequelize.getQueryInterface();

  // execute all migration from
  let fromRevision = program.rev;
  let fromPos = parseInt(program.pos);
  let stop = program.one;

  let migrationFiles = fs
    .readdirSync(migrationsDir)
    // filter JS files
    .filter((file) => {
      return file.indexOf('.') !== 0 && file.slice(-3) === '.js';
    })
    // sort by revision
    .sort((a, b) => {
      let revA = parseInt(path.basename(a).split('-', 2)[0]),
        revB = parseInt(path.basename(b).split('-', 2)[0]);
      if (revA < revB) return -1;
      if (revA > revB) return 1;
      return 0;
    })
    // remove all migrations before fromRevision
    .filter((file) => {
      let rev = parseInt(path.basename(file).split('-', 2)[0]);
      return rev >= fromRevision;
    });

  console.log('Migrations to execute:');
  migrationFiles.forEach((file) => {
    console.log('\t' + file);
  });

  if (program.list) process.exit(0);

  Async.eachSeries(
    migrationFiles,
    function (file, cb) {
      console.log('Execute migration from file: ' + file);
      migrate.executeMigration(
        queryInterface,
        path.join(migrationsDir, file),
        fromPos,
        (err) => {
          if (stop) return cb('Stopped');

          cb(err);
        },
      );
      // set pos to 0 for next migration
      fromPos = 0;
    },
    function (err) {
      console.log(err);
      process.exit(0);
    },
  );
})();
